<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Doodle Jump - Telegram Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            user-select: none;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        body {
            overflow: hidden;
            background: #6495ED;
            height: 100vh;
            width: 100vw;
            position: fixed;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, sans-serif;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 15%;
            opacity: 0.8;
            z-index: 20;
        }
        
        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(50, 50, 50, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s;
            backdrop-filter: blur(2px);
        }
        
        .control-btn:active {
            transform: scale(0.95);
            background: rgba(30, 30, 30, 0.8);
        }
        
        #scoreDisplay {
            position: absolute;
            top: max(env(safe-area-inset-top), 20px);
            left: 20px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            z-index: 10;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 20px;
        }
        
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            padding: env(safe-area-inset-top) 20px env(safe-area-inset-bottom) 20px;
        }
        
        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        #gameOver h2 {
            font-size: 36px;
            margin-bottom: 40px;
        }
        
        #finalScore {
            color: #FFD700;
            font-weight: bold;
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 16px 50px;
            background: linear-gradient(to bottom, #4CAF50, #2E8B57);
            border: none;
            border-radius: 50px;
            color: white;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        #restartBtn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .telegram-btn {
            margin-top: 20px;
            padding: 14px 30px;
            background: linear-gradient(to bottom, #0088cc, #006699);
            border-radius: 50px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-decoration: none;
            display: inline-block;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        
        @media (max-height: 700px) {
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 26px;
            }
            
            #gameOver h1 {
                font-size: 36px;
            }
            
            #gameOver h2 {
                font-size: 28px;
            }
            
            #restartBtn {
                padding: 14px 40px;
                font-size: 18px;
            }
        }
        
        @media (orientation: landscape) {
            #controls {
                bottom: 10px;
                padding: 0 10%;
            }
            
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
            
            #scoreDisplay {
                top: max(env(safe-area-inset-top), 10px);
                left: 10px;
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="scoreDisplay">Score: 0</div>
        
        <div id="controls">
            <div class="control-btn" id="leftBtn">←</div>
            <div class="control-btn" id="rightBtn">→</div>
        </div>
        
        <div id="gameOver">
            <h1>Game Over!</h1>
            <h2>Score: <span id="finalScore">0</span></h2>
            <button id="restartBtn">PLAY AGAIN</button>
            <a href="#" class="telegram-btn" id="shareBtn">SHARE SCORE</a>
        </div>
    </div>

    <script>
        // ===================== Инициализация =====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Проверка платформы
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const isTelegram = window.Telegram && window.Telegram.WebApp;
        
        // Размеры под iPhone 12 Pro (390x844)
        const PLAYER_SIZE = Math.min(window.innerWidth * 0.08, 40);
        const PLATFORM_WIDTH = window.innerWidth * 0.18;
        const PLATFORM_HEIGHT = Math.max(window.innerHeight * 0.012, 4);
        const PLATFORM_COUNT = 12;
        const GRAVITY = isIOS ? 0.32 : 0.35;
        const JUMP_STRENGTH = -10;
        const PLAYER_SPEED = 6;
        
        // Элементы UI
        const scoreDisplay = document.getElementById('scoreDisplay');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const shareBtn = document.getElementById('shareBtn');
        
        const player = {
          x: 0,
          y: 0,
          width: PLAYER_SIZE,
          height: PLAYER_SIZE,
          velocityY: 0,
          velocityX: 0,
          gravity: GRAVITY,
          jumpStrength: JUMP_STRENGTH,
        };
        
        // Предрасчет высоты прыжка
        const jumpHeight = Math.abs(JUMP_STRENGTH * (JUMP_STRENGTH / GRAVITY));
        
        const platforms = [];
        let maxHeight = 0;
        let score = 0;
        let lastPlatformIndex = -1;
        let gameActive = true;
        let scrollOffset = 0;
        let lastTime = 0;
        const fps = 60;
        const frameInterval = 1000 / fps;
        
        // ===================== Основные функции =====================
        function initGame() {
          resizeCanvas();
          
          player.x = canvas.width / 2 - player.width / 2;
          player.y = canvas.height * 0.7;
          maxHeight = player.y;
          
          initPlatforms();
          
          // Telegram-specific setup
          if (isTelegram) {
            Telegram.WebApp.expand();
            Telegram.WebApp.enableZoom(false);
            Telegram.WebApp.MainButton.setText('RESTART').show().onClick(resetGame);
            shareBtn.style.display = 'block';
          } else {
            shareBtn.style.display = 'none';
          }
        }
        
        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        
        function initPlatforms() {
          platforms.length = 0;
          
          // Стартовая платформа
          platforms.push({
            x: player.x,
            y: player.y + player.height,
            width: PLATFORM_WIDTH,
            height: PLATFORM_HEIGHT,
            index: 0,
          });
        
          let lastY = player.y + player.height;
          
          for (let i = 1; i < PLATFORM_COUNT; i++) {
            const newY = lastY - randomRange(jumpHeight * 0.7, jumpHeight * 0.9);
            const newX = Math.random() * (canvas.width - PLATFORM_WIDTH);
            
            platforms.push({
              x: newX,
              y: newY,
              width: PLATFORM_WIDTH,
              height: PLATFORM_HEIGHT,
              index: i,
            });
        
            lastY = newY;
          }
        }
        
        function drawPlayer() {
          // Тело игрока
          ctx.fillStyle = '#4CAF50';
          ctx.beginPath();
          ctx.arc(
            player.x + player.width / 2,
            player.y + player.height / 2,
            player.width / 2,
            0,
            Math.PI * 2
          );
          ctx.fill();
          
          // Глаза
          ctx.fillStyle = 'white';
          ctx.beginPath();
          ctx.arc(
            player.x + player.width / 3,
            player.y + player.height / 3,
            player.width / 7,
            0,
            Math.PI * 2
          );
          ctx.arc(
            player.x + (player.width * 2) / 3,
            player.y + player.height / 3,
            player.width / 7,
            0,
            Math.PI * 2
          );
          ctx.fill();
          
          // Зрачки
          ctx.fillStyle = '#333';
          ctx.beginPath();
          const lookDir = player.velocityX > 0 ? 1 : (player.velocityX < 0 ? -1 : 0);
          ctx.arc(
            player.x + player.width / 3 + (lookDir * 2),
            player.y + player.height / 3,
            player.width / 14,
            0,
            Math.PI * 2
          );
          ctx.arc(
            player.x + (player.width * 2) / 3 + (lookDir * 2),
            player.y + player.height / 3,
            player.width / 14,
            0,
            Math.PI * 2
          );
          ctx.fill();
          
          // Улыбка
          ctx.strokeStyle = '#333';
          ctx.lineWidth = player.width / 20;
          ctx.beginPath();
          ctx.arc(
            player.x + player.width / 2,
            player.y + player.height / 2 + player.width / 8,
            player.width / 4,
            0.2 * Math.PI,
            0.8 * Math.PI
          );
          ctx.stroke();
        }
        
        function drawPlatforms() {
          const visibleAreaTop = player.y - canvas.height * 1.5;
          const visibleAreaBottom = player.y + canvas.height;
          
          for (let i = 0; i < platforms.length; i++) {
            const p = platforms[i];
            
            if (p.y > visibleAreaTop && p.y < visibleAreaBottom) {
              // Градиент для платформы
              const gradient = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.height);
              gradient.addColorStop(0, '#A0522D');
              gradient.addColorStop(1, '#8B4513');
              ctx.fillStyle = gradient;
              
              // Скругленные платформы
              ctx.beginPath();
              roundRect(ctx, p.x, p.y, p.width, p.height, 5);
              ctx.fill();
              
              // Текстура платформы
              ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
              for (let j = 0; j < 3; j++) {
                ctx.fillRect(p.x + 5 + j * 20, p.y + 2, 10, p.height - 4);
              }
            }
          }
        }
        
        function drawBackground() {
          // Градиентное небо
          const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
          gradient.addColorStop(0, '#87CEEB');
          gradient.addColorStop(1, '#6495ED');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          // Облака с параллаксом
          ctx.fillStyle = 'rgba(255, 255, 255, 0.85)';
          for(let i = 0; i < 5; i++) {
            const x = (i * 200 + scrollOffset * 0.1) % (canvas.width + 200) - 100;
            const y = 80 + Math.sin(i * 0.8 + scrollOffset * 0.005) * 20;
            
            ctx.beginPath();
            ctx.arc(x, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 25, y - 10, 20, 0, Math.PI * 2);
            ctx.arc(x + 50, y, 25, 0, Math.PI * 2);
            ctx.arc(x + 20, y + 10, 18, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        function updatePlayer() {
          player.velocityY += player.gravity;
          player.y += player.velocityY;
          player.x += player.velocityX;
          
          // Обновление максимальной высоты
          if (player.y < maxHeight) {
            maxHeight = player.y;
            scrollOffset = canvas.height - maxHeight;
          }
        
          // Выход за нижнюю границу
          if (player.y > canvas.height) {
            gameOver();
            return;
          }
        
          // Переход через края экрана
          if (player.x + player.width < 0) {
            player.x = canvas.width;
          } else if (player.x > canvas.width) {
            player.x = -player.width;
          }
        }
        
        function checkPlatformCollision() {
          const playerBottom = player.y + player.height;
          const playerNextBottom = playerBottom + player.velocityY;
          
          for (let i = 0; i < platforms.length; i++) {
            const p = platforms[i];
            
            // Быстрая вертикальная проверка
            if (playerNextBottom > p.y && playerBottom <= p.y && player.velocityY > 0) {
              // Точная горизонтальная проверка
              if (player.x < p.x + p.width && player.x + player.width > p.x) {
                player.y = p.y - player.height;
                player.velocityY = player.jumpStrength;
                
                if (p.index !== lastPlatformIndex) {
                  score++;
                  lastPlatformIndex = p.index;
                  scoreDisplay.textContent = `Score: ${score}`;
                }
                break; // Обрабатываем только одну платформу за кадр
              }
            }
          }
        }
        
        function scrollWorld() {
          if (player.y < canvas.height * 0.3) {
            const diff = canvas.height * 0.3 - player.y;
            player.y = canvas.height * 0.3;
            
            for (let i = 0; i < platforms.length; i++) {
              const p = platforms[i];
              p.y += diff;
              
              // Перемещение платформ вышедших за экран
              if (p.y > canvas.height) {
                // Находим самую высокую платформу
                let minY = platforms[0].y;
                for (let j = 1; j < platforms.length; j++) {
                  if (platforms[j].y < minY) minY = platforms[j].y;
                }
                
                p.y = minY - randomRange(jumpHeight * 0.7, jumpHeight * 0.9);
                p.x = Math.random() * (canvas.width - PLATFORM_WIDTH);
                p.index = getNextPlatformIndex();
              }
            }
          }
        }
        
        // ===================== Вспомогательные функции =====================
        function randomRange(min, max) {
          return Math.random() * (max - min) + min;
        }
        
        function getNextPlatformIndex() {
          let maxIndex = 0;
          for (let i = 0; i < platforms.length; i++) {
            if (platforms[i].index > maxIndex) maxIndex = platforms[i].index;
          }
          return maxIndex + 1;
        }
        
        function roundRect(ctx, x, y, width, height, radius) {
          if (width < 2 * radius) radius = width / 2;
          if (height < 2 * radius) radius = height / 2;
          
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.arcTo(x + width, y, x + width, y + height, radius);
          ctx.arcTo(x + width, y + height, x, y + height, radius);
          ctx.arcTo(x, y + height, x, y, radius);
          ctx.arcTo(x, y, x + width, y, radius);
          ctx.closePath();
          return ctx;
        }
        
        function gameOver() {
          gameActive = false;
          finalScoreDisplay.textContent = score;
          gameOverScreen.style.display = 'flex';
          
          if (isTelegram) {
            Telegram.WebApp.HapticFeedback.impactOccurred('heavy');
          }
        }
        
        function resetGame() {
          gameActive = true;
          score = 0;
          lastPlatformIndex = -1;
          gameOverScreen.style.display = 'none';
          scoreDisplay.textContent = `Score: ${score}`;
          initGame();
          
          if (isTelegram) {
            Telegram.WebApp.HapticFeedback.impactOccurred('light');
          }
        }
        
        // ===================== Управление =====================
        const keys = {
          left: false,
          right: false,
        };
        
        // Кнопки управления
        document.getElementById('leftBtn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          keys.left = true;
          keys.right = false;
          
          if (isTelegram) {
            Telegram.WebApp.HapticFeedback.selectionChanged();
          }
        });
        
        document.getElementById('leftBtn').addEventListener('touchend', (e) => {
          e.preventDefault();
          keys.left = false;
        });
        
        document.getElementById('rightBtn').addEventListener('touchstart', (e) => {
          e.preventDefault();
          keys.right = true;
          keys.left = false;
          
          if (isTelegram) {
            Telegram.WebApp.HapticFeedback.selectionChanged();
          }
        });
        
        document.getElementById('rightBtn').addEventListener('touchend', (e) => {
          e.preventDefault();
          keys.right = false;
        });
        
        // Свайпы по экрану
        let touchStartX = 0;
        
        canvas.addEventListener('touchstart', (e) => {
          if (e.touches.length > 0) {
            touchStartX = e.touches[0].clientX;
            e.preventDefault();
          }
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
          if (!touchStartX || e.touches.length === 0) return;
          
          const touchX = e.touches[0].clientX;
          const diffX = touchX - touchStartX;
          
          if (Math.abs(diffX) > 10) {
            keys.left = diffX < 0;
            keys.right = diffX > 0;
          }
          e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchend', () => {
          keys.left = false;
          keys.right = false;
          touchStartX = 0;
        });
        
        // Обработка ввода
        function handleInput() {
          if (keys.left) {
            player.velocityX = -PLAYER_SPEED;
          } else if (keys.right) {
            player.velocityX = PLAYER_SPEED;
          } else {
            player.velocityX = 0;
          }
        }
        
        // ===================== Игровой цикл =====================
        function gameLoop(timestamp) {
          if (!gameActive) {
            requestAnimationFrame(gameLoop);
            return;
          }
          
          // Контроль FPS
          if (timestamp < lastTime + frameInterval) {
            requestAnimationFrame(gameLoop);
            return;
          }
          
          lastTime = timestamp;
          
          // Обновление состояния
          handleInput();
          updatePlayer();
          
          if (gameActive) {
            checkPlatformCollision();
            scrollWorld();
            
            // Отрисовка
            drawBackground();
            drawPlatforms();
            drawPlayer();
          }
          
          requestAnimationFrame(gameLoop);
        }
        
        // ===================== Обработка событий =====================
        restartBtn.addEventListener('click', resetGame);
        
        shareBtn.addEventListener('click', () => {
          if (isTelegram) {
            Telegram.WebApp.showAlert(`I scored ${score} points in Doodle Jump!`);
          } else {
            alert(`Share your score: ${score} points!`);
          }
        });
        
        function handleOrientation() {
          const isLandscape = window.innerWidth > window.innerHeight;
          player.gravity = isLandscape ? 0.25 : GRAVITY;
          initGame();
        }
        
        window.addEventListener('resize', handleOrientation);
        window.addEventListener('orientationchange', handleOrientation);
        
        // ===================== Запуск игры =====================
        initGame();
        gameLoop(0);
    </script>
</body>
</html>
